/*! Переполнение и ошибки при работе с целыми типами в Си
    overflow - переполнение (когда выходишь за "рамки" возможного значения допустим
                                         int16_t max  = 32767
                                         int16_t min  = -32768
                                         uint16_t     = 65535 будет максимальное значение а 0  минимальным
                                         если я выйду за границу то вернусь от нуля на столько знаков на сколько переборщил
                                         н-р:
                                         uint16_t a = 65536;
                                         То при выводе получится a = 0;
                                         это и называется OverFlow








*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h> // отдельная библиотека для bool
#include <inttypes.h> // для int8_t ...

int main()
{
    char a; //  он может быть знаковый signet и бюеззнаковый unsigned  это называется модификаторы
    signed char aa;
    unsigned char aaa;


    int b; // инт имеет еще больше модификаторов, так же когда используем int его максимум определяет компилятор а не стандарт

    unsigned int bb;
    signed int bbb; // signet int ==  int
    long int bbbb;
    long long int bbbbb;
    short int bbbbbb; // чтобы избежать предопределение размерности int компилятором рекомендуется пользоваться
                        // библиотекой <inttypes.h> на C++ это <cstdint>
    int8_t  i8;
    int16_t i16;
    int32_t i32;
    int64_t i64;

    //! ВАЖНОЕ ЗАМЕЧАНИЕ!
    //! не производить операции над переменными разного типа, например знаковые с беззнаковыми, будет не явное приведение типа!!!!



    //double c;
    //bool d; // нужен исполняемый файл stdbool




    return 0;
}
